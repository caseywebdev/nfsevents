#!/usr/bin/env node
'use strict';

const _ = require('underscore');
const chokidar = require('chokidar');
const moment = require('moment');
const Live = require('live-socket');
const path = require('path');
const os = require('os');
const spawn = require('child_process').spawn;
const ws = require('ws');

const FORMAT = 'YYYYMMDDhhmm.ss';
const URL = 'ws://0.0.0.0:12321';
const CACHE = {};
const LOG = console.log.bind(console);

if (os.platform() === 'darwin') {

  // Host machine (OS X)
  const socket = new Live({WebSocket: ws, url: URL});
  const watchPath = path.resolve();

  const sendMessage = function (path, stat) {
    const mtime = moment(stat.mtime).format(FORMAT);
    if (CACHE[path] && CACHE[path] === mtime) return;
    CACHE[path] = mtime;
    LOG(mtime + ' ' + path);
    socket.send('change', JSON.stringify({path, mtime}));
  };

  const handleRegister = er => {
    if (er) {
      console.error(er);
      if (/already being watched/.test(er.message)) process.exit(1);
      return;
    }

    LOG('Watching and reporting changes');
    chokidar
      .watch(watchPath, {
        alwaysStat: true,
        ignoreInitial: true,
        persistent: true
      })
      .on('add', sendMessage)
      .on('change', sendMessage);
  };

  const register = () => {
    LOG(`Registering ${watchPath}...`);
    socket.send('register', watchPath, handleRegister);
  };

  const handleClose = () => {
    LOG(`Connection closed. Retrying...`);
    register();
  };

  socket.on('close', handleClose);
  register();
} else {

  // Guest machine (Linux)
  LOG(`Listening for published changes on ${URL}`);
  const sockets = [];
  const server = new ws.Server({port: 12321});

  const handleRegister = (socket, watchPath, cb) => {
    const existing = _.find(sockets, {watchPath});
    if (existing) return cb(new Error(`${watchPath} is already being watched`));
    socket.watchPath = watchPath;
    cb();
  };

  const handleStderr = data => console.error(data.toString());

  const handleChange = (socket, message) => {
    const data = JSON.parse(message);
    LOG(data.mtime + ' ' + data.path);
    const child = spawn('touch', ['-mct', data.mtime, data.path]);
    child.stderr.on('data', handleStderr);
  };

  const handleClose = socket => sockets.splice(sockets.indexOf(socket), 1);

  const handleConnection = socket => {
    sockets.push(socket = new Live({socket}));
    socket.on('register', _.partial(handleRegister, socket));
    socket.on('change', _.partial(handleChange, socket));
    socket.on('close', _.partial(handleClose, socket));
  };

  server.on('connection', handleConnection);
}
